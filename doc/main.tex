\newcommand{\KEYWORDS}{Evolution\"are Algorithmen, one-dimensional bin packing}
\newcommand{\TITLE}{Entwicklung eines evolution\"aren Algorithmus zur Bearbeitung des eindimensionalen Beh\"alterproblems}
\newcommand{\SUBTITLE}{Projektarbeit Evolution\"are Algorithmen SS 2012}
\newcommand{\INSTITUTE}{Hochschule f\"ur Technik, Wirtschaft und Kultur Leipzig}
\newcommand{\DEPARTMENT}{Fakult\"at f\"ur Informatik, Mathematik und Naturwissenschaften}
\newcommand{\AUTHOR}{Uwe Sommerlatt}
\newcommand{\SUBJECT}{}

\input{preamble.tex}

\begin{document}

    \begin{titlepage}
        \titlepageheader
        \Large
        \vspace*{-3mm}
        \begin{minipage}[t]{.942\textwidth}
            \textbf{\TITLE}        
        \end{minipage}
        \vspace{.6em}

        \large
        \SUBTITLE\\
        \INSTITUTE\\
        \DEPARTMENT\par
        \normalsize
        \begin{tabbing}
             xxxxxxxxxI \= xxxxxxxxxxxxxxxxxxx\kill
             \textbf{Autor:} \> \textit{Uwe Sommerlatt} <\href{mailto:usommerl@imn.htwk-leipzig.de?subject=\TITLE}{\texttt{usommerl@imn.htwk-leipzig.de}}>\\\\
            \textbf{Datum:} \> \today
        \end{tabbing}
        \vspace{-1.3em}
        {\color{black}\rule[0cm]{\linewidth}{0.01cm}}\par
        %\vspace{-0.4em}
        \normalsize
        \setstretch{1.2}
        \textbf{Schlüsselwörter: }\KEYWORDS
        \par
        %\textbf{Kurzfassung: }\SUBJECT  
    \end{titlepage}

    \setstretch{1.15}    
    %\thispagestyle{plain}\tableofcontents\pagestyle{scrheadings}\clearpage

    \section{Charakterisierung des Problems}
    \label{sec:problem}
    Das eindimensionale Behälterproblem (\textit{one-dimensional bin packing problem}) ist ein NP-schweres, kombinatorisches Optimierungsproblem, bei dem eine geeignete Verteilung von $n \in N$ Objekten auf $k \in N$ Behälter gesucht wird. Die Behälter haben ein einheitliches Fassungsvermögen $c \in N$ und die einzelnen Objekte unterschiedliche, nichtnegative Größen $a_1, \dots ,a_n \le c$. Das Ziel der Optimierung ist die Minimierung der Anzahl benötigter Behälter $k$ für eine fest definierte Zusammenstellung von $n$ Objekten. Formal kann das Problem wie folgt beschrieben werden.
    $$\exists f: \{1,\dots,n\} \rightarrow \{1,\dots,k\} \text{ } | \text{ } \forall j \in \{1,\dots,k\} \displaystyle\sum\limits_{i:f(i) = j}^{}{a_i \le c} \text{, }  \text{ die }k\text{ minimiert.}$$
Da bei diesem Problem nur eine Dimension der zu verpackenden Objekte berücksichtigt wird, kann es auch als eindimensionales Zuschnittproblem (\textit{one-dimensional cutting stock problem}) betrachtet werden. \parencite[485]{KorteVygen:2008}
    
    \section{Beschreibung des entwickelten Algorithmus}

    Um Methoden der evolutionären Algorithmik auf das in \autoref{sec:problem} beschriebene Problem anwenden zu können, muss zunächst eine geeignete Repräsentation für alle Lösungskandidaten des Problems modelliert werden. Diese auch als Individuum bezeichnete Repräsentation besteht aus einem Genotyp und einem Phänotyp. Der Genotyp ist das Erbgut des Individuums und stellt seinen individuellen Satz von Genen dar. In der hier vorgestellten Implementierung ist ein Gen genau ein Objekt aus einer Instanz des Behälterproblems. Dementsprechend ist der Genotyp eine Permutation aller Objekte in der Probleminstanz. Der Phänotyp ist das Erscheinungsbild bzw. die Menge aller äußeren Merkmale des Individuums und wird im Wesentlichen durch den Genotyp bestimmt. In der konkreten Umsetzung ist der Phänotyp daher eine eindeutige Zuordnung der Objekte im Genotyp zu einem Behälter. Die Translation des Genotyps in den zugehörigen Phänotyp wird durch eine Decodierungsfunktion definiert. 
    
    \subsection{Decodierungsfunktionen}    

    Bei der Verwirklichung des Algorithmus wurde mit drei verschiedenen Decodierungsfunktionen experimentiert. Häufig werden einfache Heuristiken für das Behälterproblem in einen evolutionären Algorithmus eingebettet, um die Suche nach einer möglichst optimalen Lösung zu verbessern \parencite[64]{MitsuCheng:1999}. Dieser Ansatz wurde auch bei der Realisierung der Decodierungsfunktion aufgegriffen, indem die Greedy-Heuristiken \nextfit, \firstfit und \bestfit als Decodierungsfunktionen fungieren. Die Verarbeitung der einzelnen Objekte des Genotyps durch die Decodierungsfunktion erfolgt in der Reihenfolge ihrer Indizes. Anhand der im Anschluss vorgestellten Verfahrensweisen platziert die jeweilige Funktion das bearbeitete Objekt in einen Behälter.
    \begin{itemize}
    \item Die \textbf{\nextfit}-Heuristik weist ein Objekt dem aktuellen Behälter zu, insofern es in diesen passt. Falls kein aktueller Behälter existiert oder das Objekt zu groß für den aktuellen Behälter ist, wird ein neuer Behälter erzeugt. Das Objekt wird anschließend dem neu erzeugten Behälter zugewiesen und dieser wird zum aktuellen Behälter. 
    \item Bei der \textbf{\firstfit}-Heuristik wird ein Objekt dem ersten bereits vorhandenen Behälter zugewiesen, der ausreichend Kapazität für das Objekt aufweist. Falls das Objekt in keinen vorhandenen Behälter passt, wird einer neuer Behälter erzeugt und es darin platziert.
    \item Die \textbf{\bestfit}-Heuristik weist das Objekt dem Behälter zu, der über ausreichend Kapazität für das Objekt verfügt und gleichzeitig das geringste verbleibende Fassungsvermögen aller Behälter, die das Objekt aufnehmen können, besitzt. Auch bei dieser Vorgehensweise wird ein neuer Behälter erzeugt, insofern kein vorhandener Behälter das Objekt aufnehmen kann. 
    \end{itemize}

    \subsection{Bewertungsfunktionen}
    Die eigentliche Optimierung durch den evolutionären Algorithmus erfolgt auf Basis der Güte der einzelnen Lösungskandidaten. Die Güte eines Individuums gibt an wie gut bzw. wie schlecht das Individuum das jeweilige Problem löst. Entscheidend ist der durch eine Bewertungsfunktion ermittelte Gütewert vor allem für die Selektionsoperatoren des Algorithmus. Während der praktischen Untersuchungen wurde mit zwei verschiedenen Bewertungsfunktionen $q_1$ und $q_2$ experimentiert. Je kleiner der Funktionswert dieser Bewertungsfunktionen ist, desto besser ist die durch das Individuum repräsentierte Lösung. Die relativ einfache Bewertungsfunktion $q_1$ ermittelt lediglich die Anzahl der benötigten Behälter $k$ für ein beliebiges Individuum $x$.
    $$q_1(x) = x.k$$
    Die Bewertungsfunktion $q_2$ berücksichtigt neben der Anzahl der benötigten Behälter auch das von jedem Behälter $b_i$ nicht genutzte Fassungsvermögen $r$. Dabei bezeichnet $c$ das Gesamtfassungsvermögen eines Behälters und $n$ die Anzahl der Objekte in der Probleminstanz. Durch die Funktion $q_2$ werden die Individuen besser bewertet, die das Fassungsvermögen der von ihnen genutzten Behälter möglichst effizient ausnutzen. 
    $$q_2(x) = x.k + \frac{\displaystyle\sum_{i = 1}^{k} x.b_i.r^2}{c^2*n}$$

    \subsection{Selektions-, Rekombinations- und Mutationsoperatoren}
    
    Die Operatoren für Selektion, Rekombination und Mutation beeinflussen maßgeblich die Evolution einer Population von Individuen. Für jeden dieser Evolutionsfaktoren wurden mehrere Algorithmen implementiert. Da es sich dabei um Standardalgorithmen handelt, sollen diese hier nur genannt und nicht näher erläutert werden. 

    \textbf{Selektion:} Die realisierten Selektionsalgorithmen können sowohl als Eltern- als auch als Umweltselektion eingesetzt werden. Implementiert wurden die \textit{Besten-Selektion} \parencite[65]{Weicker:2007}, die
\textit{Q-Stufige-Turnier-Selektion} \parencite[69]{Weicker:2007} und ein naiver Selektionsalgorithmus, der die Individuen zufällig auswählt.
    
    \textbf{Rekombination:} Die Rekombinationsalgorithmen müssen infolge der Beschaffenheit des Genotyps für Permutationen geeignet sein, da ansonsten nicht gewährleistet ist, dass ein gültiges Individuum entsteht. Aus diesem Grund wurden die \textit{Abbildungsrekombination} \parencite[133]{Weicker:2007} und die \textit{Ordnungsrekombination} \parencite[29]{Weicker:2007} implementiert.
    
\textbf{Mutation:} Der evolutionäre Algorithmus wurde so angelegt, dass der Einsatz des Mutationsoperators optional ist. Es ist jedoch auch möglich, mehrere Mutationen hintereinander auszuführen. Die dafür implementierten Mutationsalgorithmen sind die  
\textit{Vertauschende-Mutation} \parencite[27]{Weicker:2007}, die \textit{Invertierende-Mutation} \parencite[28]{Weicker:2007} und die \textit{Ver\-schie\-bende-Mutation} \parencite[132]{Weicker:2007}.


    \section{Bearbeitete Probleminstanzen}
    Für die praktische Analyse des entwickelten Algorithmus werden vorhandene Datensätze aus der \textit{Operations Research} (OR) Bibliothek\footnote{\url{http://people.brunel.ac.uk/~mastjjb/jeb/info.html}} von J. E. Beasley verwendet. Ursprünglich wurden diese Datensätze zur Untersuchung des \textit{Hybrid Grouping Genetic Algorithm} (HGGA) von E. Falkenauer konstruiert \parencite{Falkenauer:1996}. Die OR-Bibliothek stellt insgesamt acht Dateien mit 160 Instanzen des eindimensionalen Behälterproblems zur Verfügung. Diese wurden direkt in die Ressourcen der entwickelten Anwendung integriert, sodass alle Datensätze komfortabel bearbeitet werden können. Bei den vorhandenen Datensätzen wird zwischen Problemen der Klasse \uniform und der Klasse \triplets unterschieden. Probleme der \uniform-Klasse bestehen aus Gegenständen mit einer gleichmäßig verteilten Größe zwischen 20 und 100 Einheiten. Diese müssen in Behälter mit einem Fassungsvermögen von 150 Einheiten einsortiert werden. Die Probleme der \triplets-Klasse enthalten Gegenstände mit einer Größe von 25 bis 50 Einheiten und die zu bestückenden Behälter besitzen ein Fassungsvermögen von 100 Einheiten. Aufgrund der Konstruktion der \triplets-Probleminstanzen, wird für einen gut gefüllten Behälter ein großer Gegenstand und zwei kleinere benötigt. Dabei muss der große Gegenstand mehr als die Hälfte des Fassungsvermögens des Behälters einnehmen. Die Intention bei der Entwicklung der \triplets-Klasse war die Erforschung der praktischen Grenzen von Falkenauers HGGA \parencite[17]{Falkenauer:1996}. Aus diesem Grund sind Probleminstanzen der \triplets-Klasse als komplexer einzustufen als Instanzen der \uniform-Klasse.

    Alle Probleminstanzen werden durch einen eindeutigen Identifikator gekennzeichnet. Probleme deren Identifikator mit einem '\texttt{u}' beginnt gehören zur \uniform-Klasse. Identifikatoren, die mit einem '\texttt{t}' beginnen, bezeichnen dagegen Probleme der \triplets-Klasse. Nach dem Buchstaben für die Klassenzugehörigkeit folgt die Anzahl der Gegenstände in der Probleminstanz und die Nummer des Problems. Für die \uniform-Klasse existieren jeweils zwanzig Probleme mit 120, 250, 500 und 1000 Gegenständen. Die Nummerierung beginnt für jede Problemgröße von neuem bei 0. Valide Identifikatoren für Probleme der \uniform-Klasse sind somit beispielsweise \texttt{u120\_00}, \texttt{u250\_00} oder \texttt{u500\_19}. Analog dazu existieren jeweils zwanzig Probleme mit 60, 120, 249 und 501 Gegenständen für die \triplets-Klasse. Der Aufbau der Identifikatoren ist mit denen der \uniform-Klasse identisch.

    Die theoretisch minimal benötigte Anzahl an Behältern für eine Probleminstanz kann wie folgt dargestellt werden. $$k_{tmin} = \left\lceil \frac{\sum_{i=1}^{n} a_i}{b} \right\rceil$$

Im Verlauf der Untersuchungen von E. Falkenauer mit dem HGGA konnte diese theoretisch optimale Lösung für alle Instanzen außer \texttt{u120\_08}, \texttt{u120\_19}, \texttt{u250\_07}, \texttt{u250\_12}, \texttt{u250\_13}, \texttt{t60\_07} und \texttt{t60\_18} auch praktisch ermittelt werden. Für die eben genannten Instanzen wurde dagegen eine Lösung errechnet, die jeweils einen Behälter mehr benötigt als die theoretische minimale Lösung. \parencite[19-22]{Falkenauer:1996} 
    
    
    \clearpage
    \pagestyle{empty}
    \printbibliography[heading=bibintoc]

\end{document}

