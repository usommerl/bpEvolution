\newcommand{\KEYWORDS}{Evolution\"are Algorithmen, one-dimensional bin packing}
\newcommand{\TITLE}{Entwicklung eines evolution\"aren Algorithmus zur Bearbeitung des eindimensionalen Beh\"alterproblems}
\newcommand{\SUBTITLE}{Projektarbeit Evolution\"are Algorithmen SS 2012}
\newcommand{\INSTITUTE}{Hochschule f\"ur Technik, Wirtschaft und Kultur Leipzig}
\newcommand{\DEPARTMENT}{Fakult\"at f\"ur Informatik, Mathematik und Naturwissenschaften}
\newcommand{\AUTHOR}{Uwe Sommerlatt}
\newcommand{\SUBJECT}{}

\input{preamble.tex}

\begin{document}

    \begin{titlepage}
        \titlepageheader
        \Large
        \vspace*{-3mm}
        \begin{minipage}[t]{.942\textwidth}
            \textbf{\TITLE}        
        \end{minipage}
        \vspace{.6em}

        \large
        \SUBTITLE\\
        \INSTITUTE\\
        \DEPARTMENT\par
        \normalsize
        \begin{tabbing}
             xxxxxxxxxI \= xxxxxxxxxxxxxxxxxxx\kill
             \textbf{Autor:} \> \textit{Uwe Sommerlatt} <\href{mailto:usommerl@imn.htwk-leipzig.de?subject=\TITLE}{\texttt{usommerl@imn.htwk-leipzig.de}}>\\\\
            \textbf{Datum:} \> \today
        \end{tabbing}
        \vspace{-1.3em}
        {\color{black}\rule[0cm]{\linewidth}{0.01cm}}\par
        %\vspace{-0.4em}
        \normalsize
        \setstretch{1.2}
        \textbf{Schlüsselwörter: }\KEYWORDS
        \par
        %\textbf{Kurzfassung: }\SUBJECT  
    \end{titlepage}

    \setstretch{1.15}    
    %\thispagestyle{plain}\tableofcontents\pagestyle{scrheadings}\clearpage

    \section{Charakterisierung des Problems}
    \label{sec:problem}
    Das eindimensionale Behälterproblem (\textit{one-dimensional bin packing problem}) ist ein NP-schweres, kombinatorisches Optimierungsproblem, bei dem eine geeignete Verteilung von $n \in N$ Objekten auf $k \in N$ Behälter gesucht wird. Die Behälter haben ein einheitliches Fassungsvermögen $c \in N$ und die einzelnen Objekte unterschiedliche, nichtnegative Größen $a_1, \dots ,a_n \le c$. Das Ziel der Optimierung ist die Minimierung der Anzahl benötigter Behälter $k$ für eine fest definierte Zusammenstellung von $n$ Objekten. Formal kann das Problem wie folgt beschrieben werden.
    $$\exists f: \{1,\dots,n\} \rightarrow \{1,\dots,k\} \text{ } | \text{ } \forall j \in \{1,\dots,k\} \displaystyle\sum\limits_{i:f(i) = j}^{}{a_i \le c} \text{, }  \text{ die }k\text{ minimiert.}$$
Da bei diesem Problem nur eine Dimension der zu verpackenden Objekte berücksichtigt wird, kann es auch als eindimensionales Zuschnittproblem (\textit{one-dimensional cutting stock problem}) betrachtet werden. \parencite[485]{KorteVygen:2008}
    
    \section{Beschreibung des entwickelten Algorithmus}
    Das entwickelte Programm zur Bearbeitung des eindimensionalen Behälterproblems wurde so gestaltet, dass sich verschiedene Teilaspekte des evolutionären Algorithmus über Parameter verändern lassen. Dadurch wird eine gezielte Untersuchung der Effektivität von unterschiedlichen Konfigurationen ermöglicht. In diesem Abschnitt sollen zunächst die einzelnen Teile des Algorithmus, wie z.B. der Aufbau des Individuums oder verschiedene Dekodierungsfunktionen, erläutert werden. Das Zusammenwirken der unterschiedlichen Komponenten im evolutionären Zyklus wird ganz am Ende des Abschnitts erörtert. 
    
    \subsection{Genotyp und Phänotyp}
    Um Methoden der evolutionären Algorithmik auf das in \autoref{sec:problem} beschriebene Problem anwenden zu können, muss zunächst eine geeignete Repräsentation für alle Lösungskandidaten des Problems modelliert werden. Diese auch als Individuum bezeichnete Repräsentation besteht aus dem Genotyp und dem Phänotyp. Der Genotyp ist das Erbgut des Individuums und stellt seinen spezifischen Satz von Genen dar. In der hier vorgestellten Implementierung ist ein Gen genau ein Objekt aus einer Instanz des Behälterproblems. Dementsprechend ist der Genotyp eine Permutation aller Objekte in der Probleminstanz. Der Phänotyp ist das Erscheinungsbild bzw. die Menge aller äußeren Merkmale des Individuums und wird im Wesentlichen durch den Genotyp bestimmt. In der konkreten Umsetzung ist der Phänotyp daher eine eindeutige Zuordnung der Objekte im Genotyp zu einem Behälter. Die Translation des Genotyps in den zugehörigen Phänotyp wird durch eine Decodierungsfunktion definiert. 
    
    \subsection{Decodierungsfunktionen}    

    Bei der Verwirklichung des Algorithmus wurde mit drei verschiedenen Decodierungsfunktionen experimentiert. Häufig werden einfache Heuristiken für das Behälterproblem in einen evolutionären Algorithmus eingebettet, um die Suche nach einer möglichst optimalen Lösung zu verbessern \parencite[64]{MitsuCheng:1999}. Dieser Ansatz wurde auch bei der Realisierung der Decodierungsfunktion gewählt, indem die Greedy-Heuristiken \nextfit, \firstfit und \bestfit als Decodierungsfunktionen verwendet wurden. Die Verarbeitung der einzelnen Objekte des Genotyps durch die Decodierungsfunktion erfolgt in der Reihenfolge ihrer Indizes. Anhand der im Anschluss vorgestellten Verfahrensweisen platziert die jeweilige Funktion das bearbeitete Objekt in einen Behälter.
    \newpage
    \begin{itemize}
    \item Die \textbf{\nextfit}-Heuristik weist ein Objekt dem aktuellen Behälter zu, insofern es in diesen passt. Falls kein aktueller Behälter existiert oder das Objekt zu groß für den aktuellen Behälter ist, wird ein neuer Behälter erzeugt. Das Objekt wird anschließend dem neu erzeugten Behälter zugewiesen und dieser wird zum aktuellen Behälter. 
    \item Bei der \textbf{\firstfit}-Heuristik wird ein Objekt dem ersten bereits vorhandenen Behälter zugewiesen, der ausreichend Kapazität für das Objekt aufweist. Falls das Objekt in keinen vorhandenen Behälter passt, wird einer neuer Behälter erzeugt und es darin platziert.
    \item Die \textbf{\bestfit}-Heuristik weist das Objekt dem Behälter zu, der über ausreichend Kapazität für das Objekt verfügt und gleichzeitig das geringste verbleibende Fassungsvermögen aller Behälter, die das Objekt aufnehmen können, besitzt. Auch bei dieser Vorgehensweise wird ein neuer Behälter erzeugt, insofern kein vorhandener Behälter das Objekt aufnehmen kann. 
    \end{itemize}

    \subsection{Bewertungsfunktionen}
    \label{subsec:qualityfunction}
    Die eigentliche Optimierung durch den evolutionären Algorithmus erfolgt auf Basis der Güte der einzelnen Lösungskandidaten. Die Güte eines Individuums gibt an wie gut bzw. wie schlecht das Individuum das jeweilige Problem löst. Entscheidend ist der durch eine Bewertungsfunktion ermittelte Gütewert vor allem für die Selektionsoperatoren des Algorithmus. Während der praktischen Untersuchungen wurde mit zwei verschiedenen Bewertungsfunktionen $q_1$ und $q_2$ gearbeitet. Je kleiner der Funktionswert dieser Bewertungsfunktionen ist, desto besser ist die durch das Individuum repräsentierte Lösung. Die relativ einfache Bewertungsfunktion $q_1$ ermittelt lediglich die Anzahl der benötigten Behälter $k$ für ein beliebiges Individuum $x$.
    $$q_1(x) = x.k$$
    Die Bewertungsfunktion $q_2$ berücksichtigt neben der Anzahl der benötigten Behälter auch das von jedem Behälter $b_i$ nicht genutzte Fassungsvermögen $r$. Dabei bezeichnet $c$ das Gesamtfassungsvermögen eines Behälters und $n$ die Anzahl der Objekte in der Probleminstanz. Durch die Funktion $q_2$ werden die Individuen der Population besser bewertet, die das Fassungsvermögen der von ihnen genutzten Behälter möglichst effizient ausnutzen. 
    $$q_2(x) = x.k + \frac{\displaystyle\sum_{i = 1}^{k} x.b_i.r^2}{c^2*n}$$

    \subsection{Operatoren}
    
    Die Operatoren für Selektion, Rekombination und Mutation beeinflussen maßgeblich die Evolution einer Population von Individuen. Für jeden dieser Evolutionsfaktoren wurden mehrere Algorithmen implementiert. Da es sich dabei um Standardalgorithmen handelt, sollen diese hier nur genannt und nicht näher erläutert werden. 

    \textbf{Selektion:} Die realisierten Selektionsalgorithmen können sowohl als Eltern- als auch als Umweltselektion eingesetzt werden. Implementiert wurden die \textit{Besten-Selektion} \parencite[65]{Weicker:2007}, die
\textit{Q-Stufige-Turnier-Selektion} \parencite[69]{Weicker:2007} und ein einfacher Algorithmus, der eine probabilistische Indexselektion realisiert.
    
    \textbf{Rekombination:} Die Rekombinationsalgorithmen müssen infolge der Beschaffenheit des Genotyps für Permutationen geeignet sein, da ansonsten nicht gewährleistet ist, dass ein gültiges Individuum entsteht. Aus diesem Grund wurden die \textit{Abbildungsrekombination} \parencite[133]{Weicker:2007} und die \textit{Ordnungsrekombination} \parencite[29]{Weicker:2007} implementiert.
    
\textbf{Mutation:} Der evolutionäre Algorithmus wurde so angelegt, dass der Einsatz des Mutationsoperators optional ist. Es ist jedoch auch möglich, mehrere Mutationen hintereinander auszuführen. Die für die Mutation verwendeten Algorithmen müssen ebenfalls für Permutationen geeignet sein. Demzufolge wurde die  
\textit{Vertauschende-Mutation} \parencite[27]{Weicker:2007}, die \textit{Invertierende-Mutation} \parencite[28]{Weicker:2007} und die \textit{Ver\-schie\-bende-Mutation} \parencite[132]{Weicker:2007} implementiert.

\subsection{Diversitätsmaß}
       
Die Diversität ist ein Maß für die Vielfalt der Genotypen in einer Population. Zur Ermittlung dieses Maßes wird in der konkreten Umsetzung ein Hashwert von jedem Genotyp in der Population erzeugt. Der Hashwert von zwei Genotypen ist gleich, insofern diese die gleiche Permutation von Objekten verkörpern.
In der praktischen Umsetzung wird die Diversität berechnet, indem die Anzahl der einzigartigen Hashwerte in der Population durch die Anzahl der Individuen dividiert und das Ergebnis anschließenden mit 100 multipliziert wird. Folglich drückt ein Diversitätswert von 100 aus, dass jeder Genotyp in der Population einzigartig ist. Umso stärker der errechnete Wert unterhalb von 100 liegt, desto mehr Duplikate eines odere mehrerer Genotypen existieren in der Population. Aufgrund von Hash-Kollisionen kann es in seltenen Fällen vorkommen, dass die tatsächliche Diversität größer ist, als durch das Verfahren berechnet wurde. In Ermangelung von alternativen Ansätzen wird dieser Fehler toleriert.

    \subsection{Zyklus des evolutionären Algorithmus}

    In \autoref{lis:cycle} ist der Ablauf des gesamten evolutionären Algorithmus als Pseudocode dargestellt. Neben den dargestellten Parametern muss zusätzlich spezifiziert werden, welche Decodierungsfunktion alle Individuen verwenden sollen. Die Initialisierung der Population erfolgt, indem die Liste der einzusortierenden Objekte für jedes Individuum zufällig permutiert wird. Das Individuum bildet mittels der Decodierungsfunktion aus dem so entstandenen Genotyp den Phänotyp und kann anschließend mit der übergebenen Gütefunktion bewertet werden. Der Zyklus des Algorithmus terminiert, sobald ein Individuum gefunden wurde, das so viele Behälter verwendet wie theoretisch für die bearbeitete Probleminstanz minimal ist. Eine Diskussion zu der theoretisch minimal benötigten Anzahl an Behältern für eine Probleminstanz befindet sich in \autoref{sec:instances}. Als zusätzliche Terminierungsbedingung kann eine maximale Anzahl an Generationen festgelegt werden, die vom Algorithmus berechnet werden.

\begin{lstlisting}[morekeywords={while,do,return,for}, escapechar=!, caption=Evolutionärer Behälter-Algorithmus, label=lis:cycle]
 EA-BEHÄLTER-ALGORITHMUS( Bewertungsfunktion !$\xi$!, Recombination !$\delta$!, 
                          Elternselektion !$\alpha_{1}$!, Umweltselektion !$\alpha_{2}$!,
                          Populationsgröße !$\lambda$!, Mutationen !$\Upsilon$! )
 !\textit{t}! !$\leftarrow$! 0
 !\textit{P(t)}! !$\leftarrow$! initialisiere Population mit !$\lambda$! Individuen
 bewerte alle Individuen aus !\textit{P(t)}! mit Bewertungsfunktion !$\xi$!
 while Terminierungsbedingung nicht erfüllt
 do !$\ulcorner$\textit{P}$'$! !$\leftarrow$! selektiere !$\lambda$/3! Eltern aus !\textit{P(t)}! mit !$\alpha_{1}$!
     !\textit{P}$''$! !$\leftarrow$! erzeuge Nachkommen durch Rekombination !$\delta$! aus !\textit{P}$'$!
     for !$\upsilon$! !$\in$! !$\Upsilon$! 
     do !$\sqsubset$ \textit{P}$''$! !$\leftarrow$! mutiere die Individuen in !\textit{P}$''$! mit !$\upsilon$!
     bewerte alle Individuen aus !\textit{P}$''$! mit Bewertungsfunktion !$\xi$!
     !\textit{t}! !$\leftarrow$! !\textit{t}! + 1
    !$\llcorner$\textit{P(t)}! !$\leftarrow$! selektiere !$\lambda$! Individuen aus !\textit{P}$''$\hspace{1mm}$\circ$! !\textit{P(t - 1)}! mit !$\alpha_{2}$!
 return bestes Individuum aus !\textit{P(t)}!
\end{lstlisting}

Bei jedem Evolutionsschritt wird zunächst $\frac{1}{3}$ der Population mittels des spezifizierten Selektionsalgorithmus als Eltern ausgewählt. Aus den Eltern werden mithilfe des Rekombinationsalgorithmus Nachkommen erzeugt, wobei auf den Einsatz von Rekombinationswahrscheinlichkeiten verzichtet wurde. Für die Rekombination werden die Eltern in zufälliger Reihenfolge in eine zyklische Liste einsortiert. Anschließend vermehrt sich jeder Elter je einmal mit seinen direkten Nachbarn in der Liste. Insofern ein oder mehrere Mutationsalgorithmen spezifiziert wurden, werden diese in der angegebenen Reihenfolge auf jedes neu erzeugte Individuum angewendet. Am Ende des Evolutionsschritts wird eine Umweltselektion auf die neu erzeugten und sämtliche alten Individuen angewendet. Dadurch wird gewährleistet, dass die Populationsgröße stets konstant bleibt.


    \section{Bearbeitete Probleminstanzen}
    \label{sec:instances}
    Für die praktische Analyse des entwickelten Algorithmus werden vorhandene Datensätze aus der \textit{Operations Research} (OR) Bibliothek\footnote{\url{http://people.brunel.ac.uk/~mastjjb/jeb/info.html}} von J. E. Beasley verwendet. Ursprünglich wurden diese Datensätze zur Untersuchung des \textit{Hybrid Grouping Genetic Algorithm} (HGGA) von E. Falkenauer konstruiert \parencite{Falkenauer:1996}. Die OR-Bibliothek stellt insgesamt acht Dateien mit 160 Instanzen des eindimensionalen Behälterproblems zur Verfügung. Diese wurden direkt in die Ressourcen der entwickelten Anwendung integriert, sodass alle Probleminstanzen komfortabel bearbeitet werden können. Bei den vorhandenen Datensätzen wird zwischen Problemen der Klasse \uniform und der Klasse \triplets unterschieden. Probleme der \uniform-Klasse bestehen aus Gegenständen mit einer gleichmäßig verteilten Größe zwischen 20 und 100 Einheiten. Diese müssen in Behälter mit einem Fassungsvermögen von 150 Einheiten einsortiert werden. Die Probleme der \triplets-Klasse enthalten Gegenstände mit einer Größe von 25 bis 50 Einheiten und die zu bestückenden Behälter besitzen ein Fassungsvermögen von 100 Einheiten. Aufgrund der Konstruktion der \triplets-Probleminstanzen, wird für einen gut gefüllten Behälter ein großer Gegenstand und zwei kleinere benötigt. Dabei muss der große Gegenstand mehr als die Hälfte des Fassungsvermögens des Behälters einnehmen. Die Intention bei der Entwicklung der \triplets-Klasse war die Erforschung der praktischen Grenzen von Falkenauers HGGA \parencite[17]{Falkenauer:1996}. Aus diesem Grund sind Probleminstanzen der \triplets-Klasse als komplexer einzustufen als Instanzen der \uniform-Klasse.

    Alle Probleminstanzen werden durch einen eindeutigen Identifikator gekennzeichnet. Probleme deren Identifikator mit einem '\texttt{u}' beginnt gehören zur \uniform-Klasse. Identifikatoren, die mit einem '\texttt{t}' beginnen, bezeichnen dagegen Probleme der \triplets-Klasse. Nach dem Buchstaben für die Klassenzugehörigkeit folgt die Anzahl der Gegenstände in der Probleminstanz und die Nummer des Problems. Für die \uniform-Klasse existieren jeweils zwanzig Probleme mit 120, 250, 500 und 1000 Gegenständen. Die Nummerierung beginnt für jede Problemgröße von neuem bei 0. Valide Identifikatoren für Probleme der \uniform-Klasse sind somit beispielsweise \texttt{u120\_00}, \texttt{u250\_00} oder \texttt{u500\_19}. Analog dazu existieren jeweils zwanzig Probleme mit 60, 120, 249 und 501 Gegenständen für die \triplets-Klasse. Der Aufbau der Identifikatoren ist mit denen der \uniform-Klasse identisch.

    Die theoretisch minimal benötigte Anzahl an Behältern für eine Probleminstanz kann wie folgt dargestellt werden. $$k_{min} = \left\lceil \frac{\sum_{i=1}^{n} a_i}{b} \right\rceil$$

Im Verlauf der Untersuchungen von E. Falkenauer mit dem HGGA konnte diese theoretisch optimale Lösung für alle Instanzen außer \texttt{u120\_08}, \texttt{u120\_19}, \texttt{u250\_07}, \texttt{u250\_12}, \texttt{u250\_13}, \texttt{t60\_07} und \texttt{t60\_18} auch praktisch ermittelt werden. Für die eben genannten Instanzen wurde dagegen eine Lösung gefunden, die jeweils einen Behälter mehr benötigt als die theoretische minimale Lösung. \parencite[19-22]{Falkenauer:1996} 
    
    \section{Untersuchung des entwickelten Algorithmus}
    \label{sec:evaluation}
    
    \subsection{Vergleich der Decodierungsfunktionen}

    Zur Feststellung der effektivsten Decodierungsfunktion wurde willkürlich eine Probleminstanz ausgewählt (\texttt{u120\_00}) und anschließend mehrfach mit dem Algorithmus bearbeitet. Insgesamt wurden 11 Testläufe je Decodierungsfunktionen durchgeführt. Im Anschluss wurde für jede Funktion der Datensatz ausgewählt, bei dem die Ausführungszeit des Testlaufs dem Median aller 11 Laufzeiten entsprach. 
    \begin{figure}[h]
        \center
        \input{figures/test-decoding-functions}
        \caption{Vergleich der \nextfit-, \firstfit- und \bestfit-Decodierungsfunktion} 
        \label{plt:decfunc}
    \end{figure}
    In \autoref{plt:decfunc} wurden diese drei Datensätze exemplarisch gegenübergestellt. Das Diagramm verdeutlicht, wie stark der Decodierungsalgorithmus den Phänotyp des Individuums und letztendlich die Effizienz des gesamten Algorithmus beeinflusst. Die evolutionäre Suche unter Verwendung der \bestfit-Heuristik nähert sich in der Gegenüberstellung deutlich schneller der unteren Grenze der benötigten Behälter ($k_{min}$) an. Dagegen führt die Suche mit der \nextfit- und \firstfit-Heuristik in den Tests erst sehr viel später oder häufig auch überhaupt nicht zu einer minimalen Lösung.

    \subsection{Vergleich der Mutationsoperatoren}
    \label{subsec:mutation-comparison}
    Um die Mutationsalgorithmen zu vergleichen, wurde die Probleminstanz \texttt{u120\_02} unter Verwendung der implementierten Algorithmen jeweils 11-mal bearbeitet. Im Anschluss wurde bei allen Testläufen ermittelt, in welcher Generation ein Individuum gefunden wurde, das einer theoretisch minimalen Lösung entspricht. Von diesen Werten wurde für jeden Algorithmus der Median gebildet und zum Vergleich der Mutationsverfahren verwendet. Konnte in einem Test keine minimale Lösung gefunden werden, wurde der Wert des Testlaufs auf $\infty$ gesetzt. Der Vergleich auf Basis der Generation wurde gewählt, da dabei die unterschiedlichen Laufzeiten der Mutationsalgorithmen keinen Einfluss haben.    

    \begin{figure}[h]
        \center
        \input{figures/test-mutations-01}
        \caption{Untersuchung verschiedener Mutationsalgorithmen} 
        \label{plt:mutations01}
    \end{figure}

    \autoref{plt:mutations01} zeigt das Resultat dieses Vergleichs. Das Verhältnis über den Balken des Diagramms gibt an, wie häufig die Suche in der entsprechenden Konfiguration mit einer theoretisch minimalen Lösung beendet wurde. Interessant am Endergebnis des Experiments ist, dass die Suche im Mittel am schnellsten zu einer optimalen Lösung führte, wenn überhaupt kein Mutationsoperator eingesetzt wurde. Des Weiteren erwies sich die Invertierende-Mutation als am schlechtesten geeignet für die bearbeitete Problemstellung. Über die gesamte Anzahl an Testläufen konnte beim Einsatz der Verschiebenden-Mutation oder der Vertauschenden-Mutation immer eine minimalen Lösung ermittelt werden. Ein Hintereinanderausführen beider Mutationen konnte die Suche jedoch nicht beschleunigen und führte nur in 10 von 11 Testläufen zu einer optimalen Lösung. 

    Wurde die Suche ohne Mutationsalgorithmus und ausschließlich mit Hilfe des Rekombinations- und der Selektions-Operatoren durchgeführt, konnte nur in 54\% der Fälle eine minimale Lösung gefunden werden. Eine Ursache dafür ist wahrscheinlich die sinkende Diversität im Verlauf der Evolution. \autoref{plt:mutations02} vergleicht die Entwicklung der Diversität anhand zweier Testläufe. Ein Testlauf wurde ohne Mutationsoperator durchgeführt und ein weiterer mit der Verschiebenden-Mutation. In der Abbildung ist deutlich zu erkennen, wie die Verschiebende-Mutation die Diversität konstant bei einem Wert von 100 hält, während diese ohne Einsatz eines Mutationsoperators immer weiter absinkt.

    \begin{figure}[h]
        \center
        \input{figures/test-mutations-02}
        \caption{Entwicklung der Diversität mit und ohne Mutationsoperator} 
        \label{plt:mutations02}
    \end{figure}

    \subsection{Vergleich der Rekombinationsalgorithmen}

    Beim Experiment zur Untersuchung der Rekombinationsverfahren wurde analog zur Untersuchung der Mutationsoperatoren vorgegangen (vgl. \autoref{subsec:mutation-comparison}). Diesmal wurde die Probleminstanz \texttt{u120\_15} bearbeitet und statt des Algorithmus für die Mutation ausschließlich der verwendete Rekombinationsalgorithmus variiert. Das Ergebnis des Vergleichs ist in \autoref{plt:recombinations} dargestellt. In der Abbildung wird deutlich, dass die Ermittlung einer minimalen Lösung unter Verwendung der Ordnungsrekombination wesentlich länger dauerte als mit der Abbildungsrekombination und nur in 73\% der Testläufe überhaupt erfolgreich war.

    \begin{figure}[h]
        \center
        \input{figures/test-recombinations}
        \caption{Gegenüberstellung verschiedener Recombinationsalgorithmen} 
        \label{plt:recombinations}
    \end{figure}

    Während der Untersuchungen wurde noch ein weiterer Rekombinationsoperator entwickelt, der bei jeder Anwendung zufällig entweder eine Abbildungsrekombination oder eine Ordnungsrekombination durchführt. Dieser Ansatz erwies sich im Mittel am effektivsten, wobei der Unterschied zur Abbildungsrekombination nicht signifikant ist.

    \subsection{Vergleich der Bewertungsfunktionen}
    Die in \autoref{subsec:qualityfunction} vorgestellten Bewertungsfunktionen $q_1$ und $q_2$ wurden anhand von Probleminstanz \texttt{u120\_13} untersucht. Im Unterschied zu den vorangegangenen Experimenten wurden diesmal jeweils 21 Testläufe pro Bewertungsfunktion durchgeführt. Bis auf die Einstellung der Bewertungsfunktion entsprachen alle Parameter der am Anfang von \autoref{sec:evaluation} vorgestellten Standardkonfiguration. 
    
    Unter Verwendung der Funktion $q_1$ konnte in allen 21 Testläufen eine minimale Lösung ermittelt werden. Der Median der benötigten Generation bis zum Auffinden dieser Lösung lag bei 101 Generationen. Im Gegensatz dazu konnte mithilfe der Bewertungsfunktion $q_2$ in keinem Testlauf eine Behälterbelegung errechnet werden, die dem theoretischem Optimum von 49 Behältern entspricht. Da sich die Population bei der Verwendung von $q_2$ in Richtung des Optimums entwickelte, kann ein grundsätzlicher Implementierungsfehler ausgeschlossen werden. Am Ende eines Testlaufs mit der Funktion $q_2$ lag die Anzahl der benötigten Behälter in der Regel ein Behälter über dem theoretischen Optimum. Es ist daher zu vermuten, dass die Funktion ungeeignet ist, sobald nur noch sehr wenig Platz in allen verwendeten Behältern verfügbar ist.   
    

    \clearpage
    \pagestyle{empty}
    \printbibliography[heading=bibintoc]

\end{document}

