\newcommand{\KEYWORDS}{Evolution\"are Algorithmen, one-dimensional bin packing}
\newcommand{\TITLE}{Entwicklung eines evolution\"aren Algorithmus zur Bearbeitung des eindimensionalen Beh\"alterproblems}
\newcommand{\SUBTITLE}{Projektarbeit Evolution\"are Algorithmen SS 2012}
\newcommand{\INSTITUTE}{Hochschule f\"ur Technik, Wirtschaft und Kultur Leipzig}
\newcommand{\DEPARTMENT}{Fakult\"at f\"ur Informatik, Mathematik und Naturwissenschaften}
\newcommand{\AUTHOR}{Uwe Sommerlatt}
\newcommand{\SUBJECT}{}

\input{preamble.tex}

\begin{document}

    \begin{titlepage}
        \titlepageheader
        \Large
        \vspace*{-3mm}
        \begin{minipage}[t]{.942\textwidth}
            \textbf{\TITLE}        
        \end{minipage}
        \vspace{.6em}

        \large
        \SUBTITLE\\
        \INSTITUTE\\
        \DEPARTMENT\par
        \normalsize
        \begin{tabbing}
             xxxxxxxxxI \= xxxxxxxxxxxxxxxxxxx\kill
             \textbf{Autor:} \> \textit{Uwe Sommerlatt} <\href{mailto:usommerl@imn.htwk-leipzig.de?subject=\TITLE}{\texttt{usommerl@imn.htwk-leipzig.de}}>\\\\
            \textbf{Datum:} \> \today
        \end{tabbing}
        \vspace{-1.3em}
        {\color{black}\rule[0cm]{\linewidth}{0.01cm}}\par
        %\vspace{-0.4em}
        \normalsize
        \setstretch{1.2}
        \textbf{Schlüsselwörter: }\KEYWORDS
        \par
        %\textbf{Kurzfassung: }\SUBJECT  
    \end{titlepage}

    \setstretch{1.15}    
    %\thispagestyle{plain}\tableofcontents\pagestyle{scrheadings}\clearpage

    \section{Charakterisierung des Problems}
    \label{sec:problem}
    Das eindimensionale Behälterproblem (\textit{one-dimensional bin packing problem}) ist ein NP-schweres, kombinatorisches Optimierungsproblem, bei dem eine geeignete Verteilung von $n \in N$ Objekten auf $k \in N$ Behälter gesucht wird. Die Behälter haben ein einheitliches Fassungsvermögen $c \in N$ und die einzelnen Objekte unterschiedliche, nichtnegative Größen $a_1, \dots ,a_n \le c$. Das Ziel der Optimierung ist die Minimierung der Anzahl benötigter Behälter $k$ für eine fest definierte Zusammenstellung von $n$ Objekten. Formal kann das Problem wie folgt beschrieben werden.
    $$\exists f: \{1,\dots,n\} \rightarrow \{1,\dots,k\} \text{ } | \text{ } \forall j \in \{1,\dots,k\} \displaystyle\sum\limits_{i:f(i) = j}^{}{a_i \le c} \text{, }  \text{ die }k\text{ minimiert.}$$
Da bei diesem Problem nur eine Dimension der zu verpackenden Objekte berücksichtigt wird, kann es auch als eindimensionales Zuschnittproblem (\textit{one-dimensional cutting stock problem}) betrachtet werden. \parencite[485]{KorteVygen:2008}
    
    \section{Beschreibung des entwickelten Algorithmus}
    Das entwickelte Programm zur Bearbeitung des eindimensionalen Behälterproblems wurde so gestaltet, dass sich verschiedene Teilaspekte des evolutionären Algorithmus über Parameter verändern lassen. Dadurch wird eine gezielte Untersuchung der Effektivität von unterschiedlichen Konfigurationen des Algorithmus ermöglicht. In diesem Abschnitt sollen zunächst die einzelnen Teilaspekte, wie z.B. der Aufbau des Individuums und die verwendeten Algorithmen für die Operatoren, erläutert werden. Das Zusammenwirken der unterschiedlichen Komponenten im evolutionären Zyklus wird dann ganz am Ende des Abschnitts erörtert. 
    
    \subsection{Genotyp und Phänotyp}
    Um Methoden der evolutionären Algorithmik auf das in \autoref{sec:problem} beschriebene Problem anwenden zu können, muss zunächst eine geeignete Repräsentation für alle Lösungskandidaten des Problems modelliert werden. Diese auch als Individuum bezeichnete Repräsentation besteht aus dem Genotyp und dem Phänotyp. Der Genotyp ist das Erbgut des Individuums und stellt seinen spezifischen Satz von Genen dar. In der hier vorgestellten Implementierung ist ein Gen genau ein Objekt aus einer Instanz des Behälterproblems. Dementsprechend ist der Genotyp eine Permutation aller Objekte in der Probleminstanz. Der Phänotyp ist das Erscheinungsbild bzw. die Menge aller äußeren Merkmale des Individuums und wird im Wesentlichen durch den Genotyp bestimmt. In der konkreten Umsetzung ist der Phänotyp daher eine eindeutige Zuordnung der Objekte im Genotyp zu einem Behälter. Die Translation des Genotyps in den zugehörigen Phänotyp wird durch eine Decodierungsfunktion definiert. 
    
    \subsection{Decodierungsfunktionen}    

    Bei der Verwirklichung des Algorithmus wurde mit drei verschiedenen Decodierungsfunktionen experimentiert. Häufig werden einfache Heuristiken für das Behälterproblem in einen evolutionären Algorithmus eingebettet, um die Suche nach einer möglichst optimalen Lösung zu verbessern \parencite[64]{MitsuCheng:1999}. Dieser Ansatz wurde auch bei der Realisierung der Decodierungsfunktion gewählt, indem die Greedy-Heuristiken \nextfit, \firstfit und \bestfit als Decodierungsfunktionen fungieren. Die Verarbeitung der einzelnen Objekte des Genotyps durch die Decodierungsfunktion erfolgt in der Reihenfolge ihrer Indizes. Anhand der im Anschluss vorgestellten Verfahrensweisen platziert die jeweilige Funktion das bearbeitete Objekt in einen Behälter.
    \newpage
    \begin{itemize}
    \item Die \textbf{\nextfit}-Heuristik weist ein Objekt dem aktuellen Behälter zu, insofern es in diesen passt. Falls kein aktueller Behälter existiert oder das Objekt zu groß für den aktuellen Behälter ist, wird ein neuer Behälter erzeugt. Das Objekt wird anschließend dem neu erzeugten Behälter zugewiesen und dieser wird zum aktuellen Behälter. 
    \item Bei der \textbf{\firstfit}-Heuristik wird ein Objekt dem ersten bereits vorhandenen Behälter zugewiesen, der ausreichend Kapazität für das Objekt aufweist. Falls das Objekt in keinen vorhandenen Behälter passt, wird einer neuer Behälter erzeugt und es darin platziert.
    \item Die \textbf{\bestfit}-Heuristik weist das Objekt dem Behälter zu, der über ausreichend Kapazität für das Objekt verfügt und gleichzeitig das geringste verbleibende Fassungsvermögen aller Behälter, die das Objekt aufnehmen können, besitzt. Auch bei dieser Vorgehensweise wird ein neuer Behälter erzeugt, insofern kein vorhandener Behälter das Objekt aufnehmen kann. 
    \end{itemize}

    \subsection{Bewertungsfunktionen}
    Die eigentliche Optimierung durch den evolutionären Algorithmus erfolgt auf Basis der Güte der einzelnen Lösungskandidaten. Die Güte eines Individuums gibt an wie gut bzw. wie schlecht das Individuum das jeweilige Problem löst. Entscheidend ist der durch eine Bewertungsfunktion ermittelte Gütewert vor allem für die Selektionsoperatoren des Algorithmus. Während der praktischen Untersuchungen wurde mit zwei verschiedenen Bewertungsfunktionen $q_1$ und $q_2$ gearbeitet. Je kleiner der Funktionswert dieser Bewertungsfunktionen ist, desto besser ist die durch das Individuum repräsentierte Lösung. Die relativ einfache Bewertungsfunktion $q_1$ ermittelt lediglich die Anzahl der benötigten Behälter $k$ für ein beliebiges Individuum $x$.
    $$q_1(x) = x.k$$
    Die Bewertungsfunktion $q_2$ berücksichtigt neben der Anzahl der benötigten Behälter auch das von jedem Behälter $b_i$ nicht genutzte Fassungsvermögen $r$. Dabei bezeichnet $c$ das Gesamtfassungsvermögen eines Behälters und $n$ die Anzahl der Objekte in der Probleminstanz. Durch die Funktion $q_2$ werden die Individuen der Population besser bewertet, die das Fassungsvermögen der von ihnen genutzten Behälter möglichst effizient ausnutzen. 
    $$q_2(x) = x.k + \frac{\displaystyle\sum_{i = 1}^{k} x.b_i.r^2}{c^2*n}$$

    \subsection{Operatoren}
    
    Die Operatoren für Selektion, Rekombination und Mutation beeinflussen maßgeblich die Evolution einer Population von Individuen. Für jeden dieser Evolutionsfaktoren wurden mehrere Algorithmen implementiert. Da es sich dabei um Standardalgorithmen handelt, sollen diese hier nur genannt und nicht näher erläutert werden. 

    \textbf{Selektion:} Die realisierten Selektionsalgorithmen können sowohl als Eltern- als auch als Umweltselektion eingesetzt werden. Implementiert wurden die \textit{Besten-Selektion} \parencite[65]{Weicker:2007}, die
\textit{Q-Stufige-Turnier-Selektion} \parencite[69]{Weicker:2007} und ein einfacher Algorithmus, der eine probabilistische Indexselektion realisiert.
    
    \textbf{Rekombination:} Die Rekombinationsalgorithmen müssen infolge der Beschaffenheit des Genotyps für Permutationen geeignet sein, da ansonsten nicht gewährleistet ist, dass ein gültiges Individuum entsteht. Aus diesem Grund wurden die \textit{Abbildungsrekombination} \parencite[133]{Weicker:2007} und die \textit{Ordnungsrekombination} \parencite[29]{Weicker:2007} implementiert.
    
\textbf{Mutation:} Der evolutionäre Algorithmus wurde so angelegt, dass der Einsatz des Mutationsoperators optional ist. Es ist jedoch auch möglich, mehrere Mutationen hintereinander auszuführen. Die für die Mutation verwendeten Algorithmen müssen ebenfalls für Permutationen geeignet sein. Demzufolge wurde die  
\textit{Vertauschende-Mutation} \parencite[27]{Weicker:2007}, die \textit{Invertierende-Mutation} \parencite[28]{Weicker:2007} und die \textit{Ver\-schie\-bende-Mutation} \parencite[132]{Weicker:2007} implementiert.

\subsection{Diversitätsmaß}
       
Die Diversität ist ein Maß für die Vielfalt der Genotypen in einer Population. Zur Ermittlung dieses Maßes wird in der konkreten Umsetzung ein Hashwert von jedem Genotyp in der Population erzeugt. Der Hashwert von zwei Genotypen ist gleich, insofern diese die gleiche Permutation von Objekten verkörpern.
Die Diversität einer Population wird nun berechnet, indem die Anzahl der einzigartigen Hashwerte durch die Anzahl der Individuen dividiert und das Ergebnis anschließenden mit 100 multipliziert wird. Folglich drückt ein Diversitätswert von 100 aus, dass jeder Genotyp in der Population einzigartig ist. Umso stärker der errechnete Wert unterhalb von 100 liegt, desto mehr Duplikate eines odere mehrerer Genotypen existieren in der Population. Aufgrund von Hash-Kollisionen kann es in seltenen Fällen vorkommen, dass die tatsächliche Diversität größer ist, als durch das Verfahren berechnet wurde. In Ermangelung von alternativen Ansätzen wird diese Fehlerquelle jedoch geduldet.

   \subsection{Zyklus des evolutionären Algorithmus}

\begin{lstlisting}[morekeywords={while,do,return,for}, escapechar=!, caption=Ablauf des evolutionären Algorithmus, label=lis:cycle]
BEHÄLTER-ALGORITHMUS( Bewertungsfunktion !\textit{f}!, Recombination !\textit{r}!, 
                      Elternselektion !\textit{s1}!, Umweltselektion !\textit{s2}!,
                      Populationsgröße !$\lambda$!, Mutationen !\textit{M}! )
!\textit{t}! !$\leftarrow$! 0
!\textit{P(t)}! !$\leftarrow$! initialisiere Population mit !$\lambda$! Individuen
bewerte alle Individuen aus !\textit{P(t)}! mit Bewertungsfunktion !\textit{f}!
while Terminierungsbedingung nicht erfüllt
do !$\ulcorner$\textit{P}$'$! !$\leftarrow$! selektiere !$\lambda$/3! Eltern aus !\textit{P(t)}! mit !\textit{s1}!
    !\textit{P}$''$! !$\leftarrow$! erzeuge Nachkommen durch Rekombination !\textit{r}! aus !\textit{P}$'$!
    for !\textit{m}! !$\in$! !\textit{M}! 
    do !$\sqsubset$ \textit{P}$''$! !$\leftarrow$! mutiere die Individuen in !\textit{P}$''$! mit !\textit{m}!
    bewerte alle Individuen aus !\textit{P}$''$! mit Bewertungsfunktion !\textit{f}!
    !\textit{t}! !$\leftarrow$! !\textit{t}! + 1
   !$\llcorner$\textit{P(t)}! !$\leftarrow$! selektiere !$\lambda$! Individuen aus !\textit{P}$''$\hspace{1mm}$\circ$! !\textit{P(t - 1)}! mit !\textit{s2}!
return bestes Individuum aus !\textit{P(t)}!
\end{lstlisting}



    \section{Bearbeitete Probleminstanzen}
    Für die praktische Analyse des entwickelten Algorithmus werden vorhandene Datensätze aus der \textit{Operations Research} (OR) Bibliothek\footnote{\url{http://people.brunel.ac.uk/~mastjjb/jeb/info.html}} von J. E. Beasley verwendet. Ursprünglich wurden diese Datensätze zur Untersuchung des \textit{Hybrid Grouping Genetic Algorithm} (HGGA) von E. Falkenauer konstruiert \parencite{Falkenauer:1996}. Die OR-Bibliothek stellt insgesamt acht Dateien mit 160 Instanzen des eindimensionalen Behälterproblems zur Verfügung. Diese wurden direkt in die Ressourcen der entwickelten Anwendung integriert, sodass alle Probleminstanzen komfortabel bearbeitet werden können. Bei den vorhandenen Datensätzen wird zwischen Problemen der Klasse \uniform und der Klasse \triplets unterschieden. Probleme der \uniform-Klasse bestehen aus Gegenständen mit einer gleichmäßig verteilten Größe zwischen 20 und 100 Einheiten. Diese müssen in Behälter mit einem Fassungsvermögen von 150 Einheiten einsortiert werden. Die Probleme der \triplets-Klasse enthalten Gegenstände mit einer Größe von 25 bis 50 Einheiten und die zu bestückenden Behälter besitzen ein Fassungsvermögen von 100 Einheiten. Aufgrund der Konstruktion der \triplets-Probleminstanzen, wird für einen gut gefüllten Behälter ein großer Gegenstand und zwei kleinere benötigt. Dabei muss der große Gegenstand mehr als die Hälfte des Fassungsvermögens des Behälters einnehmen. Die Intention bei der Entwicklung der \triplets-Klasse war die Erforschung der praktischen Grenzen von Falkenauers HGGA \parencite[17]{Falkenauer:1996}. Aus diesem Grund sind Probleminstanzen der \triplets-Klasse als komplexer einzustufen als Instanzen der \uniform-Klasse.

    Alle Probleminstanzen werden durch einen eindeutigen Identifikator gekennzeichnet. Probleme deren Identifikator mit einem '\texttt{u}' beginnt gehören zur \uniform-Klasse. Identifikatoren, die mit einem '\texttt{t}' beginnen, bezeichnen dagegen Probleme der \triplets-Klasse. Nach dem Buchstaben für die Klassenzugehörigkeit folgt die Anzahl der Gegenstände in der Probleminstanz und die Nummer des Problems. Für die \uniform-Klasse existieren jeweils zwanzig Probleme mit 120, 250, 500 und 1000 Gegenständen. Die Nummerierung beginnt für jede Problemgröße von neuem bei 0. Valide Identifikatoren für Probleme der \uniform-Klasse sind somit beispielsweise \texttt{u120\_00}, \texttt{u250\_00} oder \texttt{u500\_19}. Analog dazu existieren jeweils zwanzig Probleme mit 60, 120, 249 und 501 Gegenständen für die \triplets-Klasse. Der Aufbau der Identifikatoren ist mit denen der \uniform-Klasse identisch.

    Die theoretisch minimal benötigte Anzahl an Behältern für eine Probleminstanz kann wie folgt dargestellt werden. $$k_{min} = \left\lceil \frac{\sum_{i=1}^{n} a_i}{b} \right\rceil$$

Im Verlauf der Untersuchungen von E. Falkenauer mit dem HGGA konnte diese theoretisch optimale Lösung für alle Instanzen außer \texttt{u120\_08}, \texttt{u120\_19}, \texttt{u250\_07}, \texttt{u250\_12}, \texttt{u250\_13}, \texttt{t60\_07} und \texttt{t60\_18} auch praktisch ermittelt werden. Für die eben genannten Instanzen wurde dagegen eine Lösung gefunden, die jeweils einen Behälter mehr benötigt als die theoretische minimale Lösung. \parencite[19-22]{Falkenauer:1996} 
    
    \section{Untersuchung des entwickelten Algorithmus}
    
    \subsection{Vergleich der Decodierungsfunktionen}

    Zur Feststellung der effektivsten Decodierungsfunktion wurde willkürlich eine Probleminstanz ausgewählt und anschließend mehrfach mit dem Algorithmus bearbeitet. Dabei wurden jeweils 11 Testläufe je Decodierungsfunktionen durchgeführt. Im Anschluss wurde für jede Funktion der Testlauf ausgewählt, bei dem die Laufzeit dem Median aller 11 Laufzeiten entsprach. In \autoref{plt:decfunc} wurden diese drei Datensätze in einem Diagramm gegenübergestellt, wobei auf der y-Achse die Anzahl der benötigten Behälter des besten Individuums der Population aufgetragen wurde. Die Abbildung verdeutlicht, wie stark die Wahl des Decodierungsalgorithmus den Phänotyp und letztendlich die Effizienz des gesamten Algorithmus beeinflusst. Mittels der \bestfit-Heuristik wird in diesem Beispiel schon in Generation 0 eine Lösung gefunden, die nur 2 Behälter über der theoretisch minimalen Lösung von 48 Behältern liegt. Dagegen benötigt die beste mit der \nextfit-Heuristik erstellte Lösung in Generation 0 insgesamt 10 Behälter mehr als $k_{min}$. In allen Testläufen hat sich gezeigt, dass das Ermitteln einer $k_{min}$ äquivalenten Lösung mit der \nextfit- und der \firstfit-Heuristik tendenziell weitaus länger dauert als mit der \bestfit-Heuristik beziehungsweise häufig gar nicht gelingt.

    \begin{figure}[H]
        \input{figures/test-decoding-functions}
        \caption{Vergleich der \nextfit-, \firstfit- und \bestfit-Decodierungsfunktion anhand von Probleminstanz \texttt{u120\_00} ($k_{min}$ = 48)} 
        \label{plt:decfunc}
    \end{figure}

    \clearpage
    \pagestyle{empty}
    \printbibliography[heading=bibintoc]

\end{document}

